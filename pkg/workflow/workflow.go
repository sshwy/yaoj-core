package workflow

import (
	"encoding/json"
	"os"
	"strings"
	"time"

	"github.com/sshwy/yaoj-core/pkg/utils"
)

type Bound struct {
	// name of the node
	Name string
	// index of the file in input (output) array
	LabelIndex int
}

type Inbound Bound

type Outbound Bound

// Edge between nodes. Edges from field to node are stored in
// WorkflowGraph.Inbound.
type Edge struct {
	From Outbound
	To   Inbound
}

type Node struct {
	// processor name
	ProcName string
	// key node is attached importance by Analyzer
	Key bool
}

type WorkflowGraph struct {
	// a node itself is just a processor
	Node map[string]Node
	Edge []Edge
	// inbound consists a series of data group.
	// Inbound: map[datagroup_name]*map[field]Bound
	Inbound map[string]*map[string][]Inbound
}

// Generate json content
func (r *WorkflowGraph) Serialize() []byte {
	res, err := json.Marshal(*r)
	if err != nil {
		panic(err)
	}
	return res
}

// All edges starting from Node[nodeid]
func (r *WorkflowGraph) EdgeFrom(name string) []Edge {
	res := []Edge{}
	for _, edge := range r.Edge {
		if edge.From.Name == name {
			res = append(res, edge)
		}
	}
	return res
}

// All edges ending at Node[nodeid]
func (r *WorkflowGraph) EdgeTo(name string) []Edge {
	res := []Edge{}
	for _, edge := range r.Edge {
		if edge.To.Name == name {
			res = append(res, edge)
		}
	}
	return res
}

// Load graph from serialized data (json)
func Load(serial []byte) (*WorkflowGraph, error) {
	var graph WorkflowGraph
	err := json.Unmarshal(serial, &graph)
	if err != nil {
		return nil, err
	}
	return &graph, nil
}

// Load graph from (json) file.
func LoadFile(path string) (*WorkflowGraph, error) {
	serial, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return Load(serial)
}

// workflow describes how to perform a single testcase's judgement
type Workflow struct {
	*WorkflowGraph
	Analyzer
}

type ResultMeta struct {
	// e. g. "Accepted", "Wrong Answer"
	Title     string
	Score     float64
	Fullscore float64
	Time      time.Duration
	Memory    utils.ByteValue
	// other tags
	Property map[string]string
}

// Result of a workflow, typically generated by Analyzer.
type Result struct {
	ResultMeta
	// a list of file content to display
	File []ResultFileDisplay
}

type ResultFileDisplay struct {
	Title   string
	Content string
}

func fetchFileContent(path string, len int) []byte {
	file, err := os.Open(path)
	if err != nil {
		return []byte("[error] " + err.Error())
	}
	defer file.Close()
	b := make([]byte, len)
	file.Read(b)
	return b
}

// Display content of a text file with max-length limitation
func FileDisplay(path string, title string, len int) ResultFileDisplay {
	content := strings.TrimRight(string(fetchFileContent(path, len)), "\x00 \n\t\r")
	return ResultFileDisplay{
		Title:   title,
		Content: content,
	}
}

func NewGraph() WorkflowGraph {
	return WorkflowGraph{
		Node:    map[string]Node{},
		Edge:    []Edge{},
		Inbound: map[string]*map[string][]Inbound{},
	}
}
